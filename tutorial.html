<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Multiregeneration Tutorial</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Multiregeneration Tutorial</h1>
</header>
<h1 id="getting-started">Getting Started</h1>
<h2 id="input-files">Input files</h2>
<p>Say that we are given the following two polynomials in the variables <span class="math inline">\(x,y\)</span>. <span class="math display">\[\begin{aligned}
    f_1 &amp;= (x-1)(y-3)\\
    f_2 &amp;= (x-2)(y-4)\end{aligned}\]</span> By inspection, we see that the set of solutions consists of two points <span class="math inline">\(\{ (1,4), (2,3)\}\)</span>. To solve the system above using the multiregeneration software, let’s change into the folder “getting-started”, which contains the following three files.<br />
<strong>bertiniInput_variables</strong></p>
<pre><code>    variable_group x,y; </code></pre>
<p><strong>bertiniInput_equations</strong></p>
<pre><code>    function f1,f2;
    f1 = (x-1)*(y-3);
    f2 = (x-2)*(y-4);</code></pre>
<p><strong>inputFile.py</strong></p>
<pre><code>    degrees = [[2], [2]]</code></pre>
<p>The first two files (those with the prefix “bertiniInput”) are written in the C-like syntax used by the Bertini software. In the “bertiniInput_variables" file, the unknowns of our system of polynomials are described as variable groups with one per line. In the”bertiniInput_equations" file, our system of polynomials is described by a line beginning with "function" to set the polynomials whose common roots we aim to describe followed by one equation per line to define the polynomials in an expression of the unknowns.</p>
<p>The last file, “inputFile.py”, contains the additional data that this program needs, namely degree information. The variable “degrees” must be initialized to a list of lists, where the <span class="math inline">\(j\)</span>’th element of the <span class="math inline">\(i\)</span>’th list is the degree of the <span class="math inline">\(i\)</span>’th function in the <span class="math inline">\(j\)</span>th “variable group.” For this example there is only one variable group consisting of <span class="math inline">\(x,y\)</span>, and each function has degree two in this variable group. Therefore we use the python syntax to create a list of two lists, where the single element of the first list is the degree of <span class="math inline">\(f_1\)</span> and the single element of the second list is the degree of <span class="math inline">\(f_2\)</span>.</p>
<p>For the expert user there are many Bertini options which can improve performance. These can be added to the file “bertiniInput_trackingOptions”, and one can refer to Appendix A of the Bertini user manual for more details.</p>
<p>Bertini uses “I" to denote <span class="math inline">\(\sqrt{-1}\)</span>. The use of this symbol as a variable is not allowed. To specify the value of a constant, say <span class="math inline">\(c\)</span> is <span class="math inline">\(2.2\)</span>, put in a single line in the”bertiniInput_equations" file "c = 2.2".</p>
<h2 id="solving">Solving</h2>
<p>To solve the system, we use python2 to run the “multiregeneration.py” script <em>from the “getting-started” folder</em>. The multiregeneration script will look for input files in the directory from which it is run, so make sure that you are in the directory with the system you wish to solve.</p>
<pre><code>python2 ../multiregeneration.py</code></pre>
<p>If all goes well there will be a new directory called “run”. If there was an error, then the most likely cause is that there was an error in one of the input files.</p>
<p>The solutions will be contained in the folder</p>
<pre><code>run/_completed_smooth_solutions/depth_1</code></pre>
<p>The “depth” refers to how many equations have been solved so far. At depth <span class="math inline">\(n\)</span> the first <span class="math inline">\(n+1\)</span> equations have been solved, so for this example we look at depth 1. Later we will say more about why this is, but for the moment, know that the solutions are always in the folder corresponding to the last depth. Returning to our example, there are two files that begin with "solution_tracking_":</p>
<pre><code>solution_tracking_depth_1_gens_1_1_dim_0_varGroup_0_regenLinear_1
_pointId_326664877375_788310760051

solution_tracking_depth_1_gens_1_1_dim_0_varGroup_0_regenLinear_1
_pointId_918720474422_183602510053 </code></pre>
<p>The two file contain approximate complex values for the two solutions of the initial system. For example the first file contains the following.</p>
<pre><code>    1.999999999999996e+00 -4.107825191113079e-15
    3.000000000000000e+00 0.000000000000000e+00</code></pre>
<p>The file can be read as <span class="math display">\[\begin{aligned}
    x &amp;= 1.999999999999996 \times 10^0 - (4.107825191113079 \times 
    10^{-15})i\\
    y &amp;= 3.000000000000000 \times 10^0 + (0.0000000000000000 \times 
    10^{0})i\\\end{aligned}\]</span> which is approximately the solution <span class="math inline">\((x,y) = (2, 3)\)</span>.</p>
<h1 id="multiple-variable-groups">Multiple variable groups</h1>
<h2 id="multi-homogeneous-bézouts-theorem">Multi-homogeneous Bézout’s Theorem</h2>
<p>To motivate the notion of variable groups, we begin by stating the following formulation of Bézout’s Theorem.</p>
<p>Let <span class="math inline">\(f_1, \ldots, f_N\)</span> be polynomials with complex coefficients in <span class="math inline">\(n\)</span> variables, and let <span class="math inline">\(d_1, \ldots, d_N\)</span> denote their degrees. If <span class="math inline">\(\mathcal{V}(f_1, \ldots, f_N)\)</span> is finite, then its size is at most <span class="math inline">\(d_1d_2 \ldots d_N\)</span>.</p>
<p>For now we will assume that our system has finitely many solutions. Therefore the degrees <span class="math inline">\(d_1, \ldots, d_n\)</span> give an upper bound on the size of the output. It is not hard to construct examples where the number of solutions is exactly this bound, so in the case of general equations of degrees <span class="math inline">\(d_1, \ldots, d_n\)</span> this worst case bound cannot be improved.</p>
<p>Here is a simple example to illustrate this bound. Consider the system given by the two quadratic polynomials <span class="math display">\[\begin{aligned}
    f_1 &amp;= x^2 + xy + x - y\\
    f_2 &amp;= y^2 + 4xy - 2y.\end{aligned}\]</span> We can verify as in the previous section that this system has exactly <span class="math inline">\(d_1d_2 = 4\)</span> solutions.</p>
<p>Let us remove the <span class="math inline">\(x^2\)</span> and <span class="math inline">\(y^2\)</span> terms from the example above, and consider a system given by the polynomials <span class="math display">\[\begin{aligned}
    f_1 &amp;= xy + x - y\\
    f_2 &amp;= 4xy - 2y.\end{aligned}\]</span> The degrees <span class="math inline">\(d_1\)</span> and <span class="math inline">\(d_2\)</span> have not changed, so the Bézout bound still predicts four solutions. However, removing the square terms reduced the number of solutions to two. This is a consequence of the Multi-homogeneous Bézout Theorem, which we state below.</p>
<p>Say that for each <span class="math inline">\(1 \leq i \leq k\)</span> we have a group of variables <span class="math inline">\(\mathbf{x}_i = (x_{i,1}, \ldots, x_{i,n_i})\)</span>, for a total of <span class="math inline">\(n := n_1 + \ldots + n_k\)</span> variables. Let <span class="math inline">\(f(\mathbf{x}_1, \ldots, \mathbf{x}_k)\)</span> denote a polynomial in all <span class="math inline">\(n\)</span> variables. We define the <em>multidegree</em> of <span class="math inline">\(f\)</span> to be the integer vector <span class="math inline">\(\text{Deg}(f) = (\text{Deg}_1(f), \ldots, \text{Deg}_k(f))\)</span> where <span class="math inline">\(\text{Deg}_i(f)\)</span> is the degree of <span class="math inline">\(f\)</span> treating all variables except for <span class="math inline">\(\mathbf{x}_i\)</span> as constants.</p>
<p>Let <span class="math inline">\(f_1, \ldots, f_N\)</span> be polynomials with complex coefficients in the variables <span class="math inline">\(\mathbf{x}_1, \ldots, \mathbf{x}_n\)</span>. Consider the formal expression <span class="math inline">\(\prod_{s = 1}^N \sum_{i = 1}^{k} \text{Deg}_i(f_s) \alpha_i\)</span> in indeterminants <span class="math inline">\(\alpha_1, \ldots, \alpha_k\)</span>, and let <span class="math inline">\(B\)</span> denote the coefficient of the monomial <span class="math inline">\(\alpha_1^{n_1}\ldots \alpha_k^{n_k}\)</span>. If <span class="math inline">\(\mathcal{V}(f_1, \ldots, f_N)\)</span> is finite, than its size is at most <span class="math inline">\(B\)</span>.</p>
<p>The number <span class="math inline">\(B\)</span> is called the <em>multi-homogeneous Bézout number</em>.</p>
<p>Returning to our example, let us define variable groups <span class="math inline">\(\mathbf{x}_1 = (x), \mathbf{x}_2 = (y)\)</span>. Then <span class="math inline">\(\text{Deg}(f_1) = (1,1)\)</span> and <span class="math inline">\(\text{Deg}(f_2) = (1,1)\)</span>. From the expression <span class="math display">\[(\alpha_1 + \alpha_2)(\alpha_1 + \alpha_2) = \alpha_1^2 + 
   2\alpha_1\alpha_2 + \alpha_2^2\]</span> we see that <span class="math inline">\(B = 2\)</span>. So if <span class="math inline">\(\mathcal{V}(f_1, f_2)\)</span> is finite, its size is at most two. By grouping the variables we have a better bound on the number of solutions. Multiregeneration uses algorithms that take advantage of multivariable group structure to improve performance.</p>
<h2 id="solving-with-multiple-variable-groups">Solving with multiple variable groups</h2>
<p>When solving a polynomial system, if there is a variable group structure that gives a low multi-homogeneous Bézout number, then this gives us better guarantees about the number of solutions we will find. Moreover, the program can take advantage of this extra structure to do less work.</p>
<p>For an example of how to use variable groups, change into the directory called “multiple_variable_groups”, which contains the following files.<br />
<strong>bertiniInput_variables</strong></p>
<pre><code>    variable_group x; 
    variable_group y; </code></pre>
<p><strong>bertiniInput_equations</strong></p>
<pre><code>    function f1,f2;
    f1 = x*y + x - y;
    f2 = 4*x*y - 2*y;</code></pre>
<p><strong>inputFile.py</strong></p>
<pre><code>    degrees = [[1,1], [1,1]]</code></pre>
<p>The only differences when using multiple variable groups are the declaration of multiple variable groups in “bertiniInput_variables” and the entries of the “degree” variable, which now contains the multidegrees <span class="math inline">\(\text{Deg}(f_1)\)</span> and <span class="math inline">\(\text{Deg}(f_2)\)</span>.</p>
<p>As before we run</p>
<pre><code>python2 ../multiregeneration.py</code></pre>
<p>and look for the solution files in</p>
<pre><code>run/_completed_smooth_solutions/depth_1</code></pre>
<p>where we find the two solution files.</p>
<h1 id="solving-with-homogeneous-variable-groups">Solving with homogeneous variable groups</h1>
<p>In this section we demonstrate how to solve systems of homogeneous polynomials over complex projective space, which is a central idea in algebraic geometry. For a good introduction to projective space see chapter 8 sections 1 and 2 of <span class="citation" data-cites="clo">[@clo]</span>, or appendix A of <span class="citation" data-cites="st">[@st]</span>.</p>
<p>Consider the two homogeneous polynomials <span class="math display">\[\begin{aligned}
   f_1 &amp;= y^2z - x^3 + z^3 - xyz \\
   f_2 &amp;= yz - x^2 + xy - xz + z^2. \end{aligned}\]</span> Observe that all terms in the first equation are degree three, and all term is the second equations are degree two, so these equations are indeed homogeneous of degrees two and three. The common roots of these polynomials represent the intersection of two curves in the projective plane. If you input equations that are not homogeneous, and then try to solve them over projective space it will cause errors, so watch out for this.</p>
<p>Change into the directory called “homogeneous-variable-groups”, which contains the following files.<br />
<strong>bertiniInput_variables</strong></p>
<pre><code>   hom_variable_group x,y,z;</code></pre>
<p><strong>bertiniInput_equations</strong></p>
<pre><code>   function f1,f2;
   f1 = y^2*z - x^3 + z^3 - x*y*z;
   f2 = y*z - x^2 + x*y - x*z + z^2;</code></pre>
<p><strong>inputFile.py</strong></p>
<pre><code>   degrees = [[3], [2]]</code></pre>
<p>There are two notable differences: (1) our equations are homogeneous, and (2) we have declared a “hom_variable_group”.</p>
<p>After running the program</p>
<pre><code>python2 ../multiregeneration.py</code></pre>
<p>the output in</p>
<pre><code>run/_completed_smooth_solutions/depth_1</code></pre>
<p>will be give the homogeneous coordinates of the six solutions. Often, these coordinates are scaled so that the max norm of its entries is one.</p>
<p>One can also better performance by having multiple homogeneous groups or a mixture of homogeneous and affine groups.</p>
<h1 id="positive-dimensional-components">Positive dimensional components</h1>
<p>In this section we will introduce some of the language of algebraic geometry and numerical algebraic geometry, so that we can describe how the program handles the case where the solution set is infinite (i.e. that it contains positive dimensional components).</p>
<p>Recall that a set <span class="math inline">\(A \subset \mathbb{C}^n\)</span> is <em>algebraic</em> or <em>Zariski closed</em> if it is of the form <span class="math inline">\(\mathcal{V}(f_1, \ldots, f_N)\)</span> for polynomials <span class="math inline">\(f_i\)</span>. Similarly, a set <span class="math inline">\(A \subset \mathbb{P}^n\)</span> is <em>algebraic</em> or <em>Zariski closed</em> if it is of the form <span class="math inline">\(\mathcal{V}(f_1, \ldots, f_N)\)</span> for homogeneous polynomials <span class="math inline">\(f_i\)</span>. If an algebraic set is the union of finitly many algebraic proper subsets, the it is <em>reducible</em>. An algebraic set that is not reducible is <em>irreducible</em>. If <span class="math inline">\(A\)</span> is an algebraic set, then a maximal irreducible algebraic subset of <span class="math inline">\(A\)</span> is called an <em>irreducible component of <span class="math inline">\(A\)</span></em>, or simply a <em>component of <span class="math inline">\(A\)</span></em>.</p>
<p>The following fact is typically proven in a first commutative algebra or algebraic geometry course.</p>
<p>Every algebraic set in <span class="math inline">\(\mathbb{C}^n\)</span> or <span class="math inline">\(\mathbb{P}^n\)</span> is the union of finitely many irreducible components.</p>
<p>In the case where a polynomial system has infinitely many solutions, it is often best to describe each component separately. As a simple example, consider the system given by <span class="math display">\[\begin{aligned}
   f_1 &amp;= (y-x^2)(x-1) \\
   f_2 &amp;= (y-x^2)(y).\end{aligned}\]</span></p>
<p>The solutions consist of a parabola and a point, which are the two irreducible components. This system can be found in the “positive-dimensional” folder. The following files contain the solutions.</p>
<pre><code>      solution_tracking_depth_1_gens_1_1_dim_0_varGroup_0_regenLinear_
      1_pointId_151979748598_138051236175

      solution_vanishing_depth_1_gens_1_0_dim_1_pointId_11020904120_
      11020904120

      solution_vanishing_depth_1_gens_1_0_dim_1_pointId_462642055403_
      462642055403</code></pre>
<p>The coordinates of the isolated point are contained in the files whose name contains the string “dim_0”. The other two files, whose names contain the string “dim_1” are two points on the one dimensional parabola, which is the other irreducible component. Which two points of the parabola were chosen, and why? To answer this question, we introduce some language from numerical algebraic geometry <span class="citation" data-cites="BertiniBook SWBook">[@BertiniBook; @SWBook]</span>.</p>
<p>By a <em>hyperplane in <span class="math inline">\(\mathbb{C}^n\)</span></em>, we mean a variety of the form <span class="math inline">\(\mathcal{V}(a_0 + a_1x_1 + \ldots + a_nx_n)\)</span> where one of <span class="math inline">\(a_1, \ldots, a_n\)</span> is not zero. By a <em>hyperplane in <span class="math inline">\(\mathbb{P}^n\)</span></em> we mean a variety of the form <span class="math inline">\(\mathcal{V}(a_0x_0 + a_1x_1 + \ldots + a_nx_n)\)</span> where one of <span class="math inline">\(a_0, \ldots, a_n\)</span> is not zero. Intuitively, a <em>general hyperplane</em> is a hyperplane where the parameters <span class="math inline">\(a_i\)</span> are chosen at random, and satisfy no special relations. The program chooses “generic hyperplanes” by picking coefficients the coefficients <span class="math inline">\(a_i\)</span> to be uniform random complex numbers with real and imaginary parts in <span class="math inline">\((-1, 1)\)</span>. If coefficients are chosen randomly in this way, then it is a fact that anything true of a “generic hyperplane” will be true of a random hyperplane with probability one. For those familiar with projective geometry who would like a more rigourous definition of generic, see <span class="citation" data-cites="SWBook">[@SWBook]</span>.</p>
<p>The following fact is often proved with the use of more powerful theorems such as Bertini’s theorem and Bezout’s theorem, but we want to get down to business, so we will take it for granted.</p>
<p>Let <span class="math inline">\(X\)</span> be an irreducible algebraic variety in <span class="math inline">\(\mathbb{C}^n\)</span> or <span class="math inline">\(\mathbb{P}^n\)</span>. Then there is unique number <span class="math inline">\(d\)</span> such that the intersection of <span class="math inline">\(X\)</span> with <span class="math inline">\(d\)</span> generic hyperplanes is finite and nonempty. Moreover, the size of the intersection does not depend on the choice of generic hyperplanes.</p>
<p>The number <span class="math inline">\(d\)</span> we define to be the <em>dimension of <span class="math inline">\(X\)</span></em>, and the number size of the intersection is the <em>degree of <span class="math inline">\(X\)</span></em>. <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>Returning to the example above, the two points on the parabola which were outputed were the intersection of the parabola with one generic hyperplane. As we would expect, the fact that there are two of them means that the parabola has degree two. One of the main ideas in numerical algebraic geometry is that many questions about a <span class="math inline">\(d\)</span> dimensional irreducible variety in <span class="math inline">\(\mathbb{C}^n\)</span> or <span class="math inline">\(\mathbb{P}^n\)</span> can be answered by knowing the its intersection with <span class="math inline">\(d\)</span> generic hyperplanes. This intersection is called a <em>witness set for <span class="math inline">\(X\)</span></em>.</p>
<h1 id="tips-for-large-computations">Tips for large computations</h1>
<p>One of the main advantages of numerical methods for solving polynomial systems (over Gröbner basis methods for instance) is that they are very parallelizable. To use multiple processors to solve a system, we can set the “maxProcesses” variable in “inputFile.py”.</p>
<p><strong>inputFile.py</strong></p>
<pre><code>   degrees = [[3], [2]]
   maxProcesses = 4</code></pre>
<p>Adding more processes will only speed up the calculation if the number you choose is less than or equal to the number of CPU cores on your computer, and in fact adding more processes than you have cores will slow things down.</p>
<p>If you do not have enough time or space to find all of the solution to a particular system, then it can sometimes still be worth it to find as many solutions as you can. If this is the case, the it is recommended to use the following option in “inputFile.py” <strong>inputFile.py</strong></p>
<pre><code>   degrees = [[3], [2]]
   explorationOrder = &quot;depthFirst&quot;</code></pre>
<p>Setting this option will not decrease the time it takes for the program to finish, however it will increase the number of solutions found after any given time. Here is a vague explanation as to why: The nature of the algorithm is that “solutions at depth <span class="math inline">\(n\)</span>” lead to “solutions at depth <span class="math inline">\(n+1\)</span>.” The solutions at the last depth are the actual solutions to the system. In this way, the program first populates one depth with solutions, and then moves to the next. Setting the exploration order to “depthFirst” will ensure that if a solution is found at depth <span class="math inline">\(n\)</span>, then it is immediately used to find a solution at depth <span class="math inline">\(n+1\)</span>, before looking for other solutions at depth <span class="math inline">\(n\)</span>. The result is that the maximum number full depth solutions are found after any given time.</p>
<p>In the directory “large” there is a system of 10 polynomials, all of degree <span class="math inline">\((1,1)\)</span> with respect to variable groups <span class="math inline">\(x_0, \ldots, x_4\)</span> and <span class="math inline">\(y_0, \ldots, y_4\)</span>. This computation should take on the order of 30 seconds, so you can experiment with parallel processing, depth first order, and using multiple variable groups versus a single variable group.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>For those farmiliar with algebraic geometry, the degree of a variety in <span class="math inline">\(\mathbb{C}^n\)</span> or <span class="math inline">\(\mathbb{P}^n\)</span> is not an isomorphism invariant, since it depends on the embedding.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
